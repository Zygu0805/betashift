# FAQ Log - 2025-12-15

## 목차
1. [Generator 타입 관련](#1-generator-타입-관련)
2. [Depends와 의존성 주입](#2-depends와-의존성-주입)
3. [SQLAlchemy Model 관련](#3-sqlalchemy-model-관련)
4. [Primary Key와 Foreign Key](#4-primary-key와-foreign-key)
5. [relationship과 back_populates](#5-relationship과-back_populates)
6. [Pydantic Schema 관련](#6-pydantic-schema-관련)
7. [Python 문법 관련](#7-python-문법-관련)

---

## 1. Generator 타입 관련

### Q: Generator의 세 타입 (YieldType, SendType, ReturnType)이 각각 어떨 때 사용해?

**A: 각각 다른 상황에서 사용됩니다.**

```python
Generator[YieldType, SendType, ReturnType]
```

| 타입 | 역할 | 사용 상황 |
|------|------|----------|
| `YieldType` | yield로 내보내는 값의 타입 | 가장 흔히 사용 |
| `SendType` | send()로 받는 값의 타입 | 코루틴 패턴에서 사용 |
| `ReturnType` | return 값의 타입 | 거의 사용 안 함 |

#### 예시
```python
# 기본 Generator (YieldType만 사용)
def count_up() -> Generator[int, None, None]:
    yield 1
    yield 2
    yield 3

# SendType 사용 예시
def accumulator() -> Generator[int, int, None]:
    total = 0
    while True:
        value = yield total  # total을 내보내고, value를 받음
        total += value

gen = accumulator()
next(gen)           # 0 (초기값)
gen.send(10)        # 10
gen.send(5)         # 15
```

---

### Q: 위 예시에서 while True문이 꼭 필요해?

**A: send()를 여러 번 사용하려면 필요합니다.**

```python
# while 없이
def single_yield():
    value = yield 0  # 한 번만 받고 끝
    # 여기서 함수 종료

# while 있으면
def multi_yield():
    while True:
        value = yield 0  # 계속 받을 수 있음
```

#### get_db()에서 while이 없는 이유
```python
def get_db() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db  # 한 번만 주면 됨
    finally:
        db.close()
```

- 요청당 하나의 세션만 필요
- send()로 값을 받을 필요 없음
- 따라서 while 불필요

---

## 2. Depends와 의존성 주입

### Q: Depends는 Generator하고만 쓰이는 함수야?

**A: 아니요! Depends는 다양한 callable과 함께 사용됩니다.**

```python
# 1. Generator 함수와 사용
def get_db() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 2. 일반 함수와 사용
def get_current_user(token: str = Header(...)):
    return decode_token(token)

# 3. 클래스와 사용
class Pagination:
    def __init__(self, page: int = 1, size: int = 10):
        self.page = page
        self.size = size

# 사용
@app.get("/items")
def get_items(
    db: Session = Depends(get_db),           # Generator
    user: User = Depends(get_current_user),  # 일반 함수
    pagination: Pagination = Depends(),       # 클래스
):
    ...
```

#### Depends의 역할
- FastAPI의 의존성 주입 시스템
- Generator면 → yield 전까지 실행, 요청 끝나면 finally 실행
- 일반 함수면 → 반환값을 주입
- 클래스면 → 인스턴스 생성해서 주입

---

### Q: Depends로 코딩할 경우 향후 유지보수에는 문제가 없을까?

**A: 올바르게 사용하면 오히려 유지보수에 좋습니다.**

#### 좋은 점
- 코드 재사용성 증가
- 테스트 용이 (의존성 교체 가능)
- 관심사 분리 (비즈니스 로직 vs 인프라 로직)

#### 주의할 점
```python
# 나쁜 예: 의존성 체인이 너무 깊음
def dep_a(): ...
def dep_b(a = Depends(dep_a)): ...
def dep_c(b = Depends(dep_b)): ...
def dep_d(c = Depends(dep_c)): ...  # 4단계 체인

# 좋은 예: 체인 최소화
def get_db(): ...
def get_current_user(db = Depends(get_db)): ...  # 2단계까지
```

#### 권장 사항
- 의존성 체인은 2-3단계 이내로 유지
- 각 의존성의 역할을 명확히 분리
- 순환 의존성 피하기

---

### Q: 비즈니스 로직과 인프라 로직 분리가 무슨 뜻이야?

**A: 역할에 따라 코드를 분리하는 것입니다.**

| 구분 | 역할 | 예시 |
|------|------|------|
| **비즈니스 로직** | "무엇을" 할지 (도메인 규칙) | 캐로셀 배정 규칙, 충돌 검증 |
| **인프라 로직** | "어떻게" 연결할지 (기술적 세부사항) | DB 연결, 세션 관리, 인증 |

```python
# 인프라 로직 (database.py)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 비즈니스 로직 (services/assignment_service.py)
def check_conflict(carousel_id, start_time, end_time, db):
    """캐로셀 시간 충돌 검증 - 비즈니스 규칙"""
    ...

# Router에서 조합
@router.post("/assignments")
def create_assignment(
    data: AssignmentCreate,
    db: Session = Depends(get_db)  # 인프라
):
    check_conflict(...)  # 비즈니스
```

---

## 3. SQLAlchemy Model 관련

### Q: `__tablename__` 문법은 Base를 상속받는 class에서 테이블 이름 설정을 위해 사용하는 거야?

**A: 맞습니다!**

```python
class Airline(Base):
    __tablename__ = "airlines"  # DB에 생성될 테이블 이름
```

- 클래스 이름: `Airline` (Python에서 사용)
- 테이블 이름: `airlines` (PostgreSQL에 생성)
- 보통 클래스는 단수형, 테이블은 복수형으로 작명

---

### Q: `__repr__`은 왜 필요해?

**A: 디버깅과 로깅을 위해 사용합니다.**

```python
class Airline(Base):
    # ...
    def __repr__(self):
        return f"<Airline {self.airline_code}: {self.airline_name}>"
```

#### 효과
```python
# __repr__ 없으면
print(airline)  # <Airline object at 0x7f9b8c0d5a90>

# __repr__ 있으면
print(airline)  # <Airline KE: Korean Air>
```

- 로그에서 어떤 객체인지 바로 파악 가능
- 디버깅 시 유용
- 선택사항이지만 권장됨

---

## 4. Primary Key와 Foreign Key

### Q: PK는 테이블에서 각 엔티티에 대한 고유한 식별자라고 이해하고 있는데 맞아? FK는 뭐야?

**A: 맞습니다! FK는 다른 테이블의 PK를 참조하는 컬럼입니다.**

#### Primary Key (PK)
```python
class Airline(Base):
    airline_code = Column(String(10), primary_key=True)  # PK
```
- 테이블 내에서 각 행(row)을 고유하게 식별
- 중복 불가, NULL 불가

#### Foreign Key (FK)
```python
class Flight(Base):
    airline = Column(
        String(10),
        ForeignKey("airlines.airline_code"),  # FK → Airline의 PK 참조
        nullable=False
    )
```
- 다른 테이블의 PK를 참조
- 테이블 간 관계를 만듦
- 참조 무결성 보장 (존재하지 않는 값 참조 불가)

#### 시각적 예시
```
airlines 테이블 (PK: airline_code)
┌─────────────┬─────────────┐
│ airline_code│ airline_name│
├─────────────┼─────────────┤
│ KE          │ Korean Air  │  ← 이 PK를
│ OZ          │ Asiana      │
└─────────────┴─────────────┘

flights 테이블 (FK: airline → airlines.airline_code)
┌───────────┬─────────┐
│ flight_id │ airline │
├───────────┼─────────┤
│ KE001     │ KE      │  ← FK가 참조
│ OZ123     │ OZ      │
│ XX999     │ XX      │  ← ❌ 에러! XX는 airlines에 없음
└───────────┴─────────┘
```

---

## 5. relationship과 back_populates

### Q: relationship 함수는 각 Flight, Carousel 모델의 PK를 참조한다는 걸 뜻하는 거야? back_populates 값은 뭐야?

**A: relationship은 FK를 기반으로 ORM에서 편하게 객체를 접근하게 해주는 기능입니다.**

#### FK vs relationship
```python
# Assignment 모델에서
flight_id = Column(String(20), ForeignKey("flights.flight_id"))  # ← 실제 FK (DB 레벨)
flight = relationship("Flight", back_populates="assignments")     # ← ORM 편의기능 (Python 레벨)
```

| 개념 | 레벨 | 역할 |
|------|------|------|
| ForeignKey | DB | 실제 테이블 간 연결 (데이터 무결성) |
| relationship | Python | 연결된 객체에 쉽게 접근 |
| back_populates | Python | 양방향 접근 가능하게 함 |

#### relationship 사용 예시
```python
# relationship이 없다면...
assignment = db.query(Assignment).first()
flight = db.query(Flight).filter(Flight.flight_id == assignment.flight_id).first()

# relationship이 있으면!
assignment = db.query(Assignment).first()
flight = assignment.flight  # ← 바로 접근 가능!
```

#### back_populates의 역할
```python
# Flight 모델
assignments = relationship("Assignment", back_populates="flight")

# Assignment 모델
flight = relationship("Flight", back_populates="assignments")
```

양방향 접근 가능:
```python
# Flight → Assignment (1:N)
flight = db.query(Flight).first()
print(flight.assignments)  # 이 항공편의 모든 배정 목록

# Assignment → Flight (N:1)
assignment = db.query(Assignment).first()
print(assignment.flight)   # 이 배정의 항공편 정보
```

#### back_populates 값의 의미
```python
# Airline 모델에서
flights = relationship("Flight", back_populates="airline_info")
#                                               ↑ Flight 모델에 있는 변수명!

# Flight 모델에서
airline_info = relationship("Airline", back_populates="flights")
#                                                      ↑ Airline 모델에 있는 변수명!
```

**상대방 모델에서 나를 참조하는 변수명**을 적어줌!

---

## 6. Pydantic Schema 관련

### Q: `__init__.py`에 `__all__`을 넣어두는 이유는 뭐야? 메소드도 넣는 경우가 있어?

**A: `from 패키지 import *` 할 때 뭘 내보낼지 정의하는 것입니다.**

#### `__init__.py`의 역할
```python
# __init__.py가 없으면
from app.schemas.airline import AirlineResponse  # 길게 써야 함

# __init__.py에 import 해두면
from app.schemas import AirlineResponse  # 짧게 가능!
```

#### `__all__`의 역할
```python
# schemas/__init__.py
__all__ = ["AirlineResponse", "FlightResponse"]

# 다른 파일에서
from app.schemas import *  # __all__에 있는 것만 import됨
```

#### 메소드(함수)도 넣을 수 있나요?
**네, 가능합니다!**

```python
# utils/__init__.py
from app.utils.helpers import calculate_duration, format_time

__all__ = [
    "MyClass",           # 클래스
    "my_function",       # 함수
    "MY_CONSTANT",       # 상수
]
```

---

### Q: schemas 패키지와 models 패키지를 분리하는 이유는?

**A: 역할이 완전히 다르기 때문입니다.**

| 구분 | Models (SQLAlchemy) | Schemas (Pydantic) |
|------|---------------------|-------------------|
| **목적** | DB 테이블 구조 정의 | API 데이터 검증/변환 |
| **연결 대상** | PostgreSQL | 클라이언트 (프론트엔드) |
| **저장 여부** | DB에 저장됨 | 저장 안 함 (검증만) |

#### 흐름
```
클라이언트 (React)
      ↓ JSON 요청
  ┌─────────────┐
  │   Schemas   │  ← 데이터 검증 "이 형식 맞아?"
  │  (Pydantic) │
  └─────────────┘
      ↓ 검증된 데이터
  ┌─────────────┐
  │   Models    │  ← DB 저장 "테이블에 넣자"
  │ (SQLAlchemy)│
  └─────────────┘
      ↓ SQL
   PostgreSQL
```

---

### Q: `__pycache__` 폴더는 뭐야?

**A: Python이 자동 생성하는 캐시 폴더입니다.**

```
models/
├── __init__.py
├── airline.py
└── __pycache__/          ← Python이 자동 생성
    ├── __init__.cpython-311.pyc
    └── airline.cpython-311.pyc
```

- `.py` → 사람이 읽는 코드
- `.pyc` → Python이 실행하는 바이트코드 (컴파일된 버전)

#### 장점
```
첫 실행:  .py 읽기 → 컴파일 → 실행 (느림)
두번째:   .pyc 읽기 → 실행 (빠름!)
```

#### 삭제해도 되나요?
**네!** 다음 실행 시 자동 재생성됨. `.gitignore`에 포함되어 Git에 올라가지 않음.

---

### Q: Create나 Response 이름을 붙이면 알아서 요청검증이나 응답형식을 해주는 거야?

**A: 아니요, 이름이 아니라 Router에서 어디에 사용하느냐가 결정합니다.**

```python
# Router에서 직접 지정해줘야 함
@router.post("/", response_model=AirlineResponse)  # ← 응답용으로 지정
def create_airline(airline: AirlineCreate):        # ← 요청용으로 지정
```

이름을 `AirlineABC`로 해도 상관없음. **어디에 쓰느냐**가 역할을 결정!

---

### Q: `model_dump()`는 무슨 문법이야?

**A: Pydantic 모델을 딕셔너리로 변환하는 메서드입니다.**

```python
airline = AirlineCreate(
    airline_code="KE",
    airline_name="Korean Air",
    color_code="#0F4C81"
)

airline.model_dump()
# 결과: {"airline_code": "KE", "airline_name": "Korean Air", "color_code": "#0F4C81"}
```

#### 왜 필요해?
```python
# Pydantic 객체를 직접 넣으면 에러!
db_airline = Airline(airline)  # ❌

# 딕셔너리로 변환해서 언패킹
db_airline = Airline(**airline.model_dump())  # ✅
```

#### 버전 차이
```python
# Pydantic v1 (구버전)
airline.dict()

# Pydantic v2 (현재)
airline.model_dump()
```

---

### Q: Pydantic 모델은 어떻게 생긴 거야?

**A: BaseModel을 상속받는 클래스입니다.**

```python
from pydantic import BaseModel, Field

class AirlineCreate(BaseModel):  # ← BaseModel 상속 = Pydantic 모델
    airline_code: str = Field(..., max_length=10)
    airline_name: str
    color_code: str = "#808080"
```

#### SQLAlchemy vs Pydantic 비교
```python
# SQLAlchemy Model (DB용)
class Airline(Base):
    __tablename__ = "airlines"
    airline_code = Column(String(10), primary_key=True)

# Pydantic Model (API용)
class AirlineCreate(BaseModel):
    airline_code: str = Field(..., max_length=10)
```

| 구분 | 상속 | 용도 |
|------|------|------|
| SQLAlchemy Model | `Base` | DB 테이블 |
| Pydantic Model | `BaseModel` | API 데이터 검증 |

---

### Q: `Field(...)`에서 `...`은 무슨 의미야?

**A: Pydantic에서 "필수 값"을 의미합니다.**

```python
# ... = 필수 (반드시 입력해야 함)
airline_code: str = Field(...)

# default 값 = 선택 (안 넣으면 기본값 사용)
color_code: str = Field(default="#808080")

# None 허용 = 선택
terminal: str | None = Field(default=None)
```

#### 동작 예시
```python
AirlineCreate(
    airline_name="Korean Air",
    color_code="#0F4C81"
    # airline_code 없음!
)
# ❌ ValidationError: airline_code field required
```

`...`은 Python 내장 상수 `Ellipsis`이며, Pydantic이 "필수값" 의미로 사용.

---

### Q: AirlineBase를 상속받는 클래스들은 어디에 사용되는 거야?

**A: 각각 요청 검증용, 응답 형식용으로 Router에서 사용됩니다.**

```python
class AirlineBase(BaseModel):      # ← 공통 필드 정의 (직접 사용 X)
    airline_code: str
    airline_name: str
    color_code: str

class AirlineCreate(AirlineBase):  # ← 생성 요청용
    pass

class AirlineResponse(AirlineBase): # ← 응답용
    model_config = {"from_attributes": True}
```

#### Router에서 사용
```python
@router.post("/", response_model=AirlineResponse)  # 응답 형식
def create_airline(airline: AirlineCreate):        # 요청 검증
    db_airline = Airline(**airline.model_dump())
    # ...
    return db_airline  # → AirlineResponse로 자동 변환
```

#### `model_config = {"from_attributes": True}`
SQLAlchemy 객체 → Pydantic 모델 자동 변환을 허용하는 설정.

---

## 7. Python 문법 관련

### Q: `**` 언패킹 복습

```python
data = {"a": 1, "b": 2}

func(**data)  # = func(a=1, b=2)
```

#### model_dump()와 함께 사용
```python
airline = AirlineCreate(airline_code="KE", airline_name="Korean Air")

# 아래 두 줄은 동일
db_airline = Airline(**airline.model_dump())
db_airline = Airline(airline_code="KE", airline_name="Korean Air")
```

---

## 요약 표

| 질문 | 핵심 답변 |
|------|----------|
| Generator 세 타입? | YieldType(내보냄), SendType(받음), ReturnType(반환) |
| while True 필요? | send() 여러 번 쓰려면 필요, get_db()는 불필요 |
| Depends 역할? | FastAPI 의존성 주입, Generator/함수/클래스 모두 가능 |
| 비즈니스 vs 인프라 로직? | 비즈니스=도메인 규칙, 인프라=기술적 연결 |
| `__tablename__`? | DB 테이블 이름 설정 |
| `__repr__`? | 디버깅/로깅용 문자열 표현 |
| PK vs FK? | PK=고유 식별자, FK=다른 테이블 PK 참조 |
| relationship? | ORM에서 연결된 객체 쉽게 접근 |
| back_populates? | 양방향 접근 가능하게 함 |
| schemas vs models? | schemas=API 검증, models=DB 저장 |
| `__pycache__`? | Python 바이트코드 캐시, 삭제 가능 |
| `__all__`? | `import *` 시 내보낼 목록 정의 |
| model_dump()? | Pydantic → 딕셔너리 변환 |
| Field(...)? | 필수 값 표시 |
| model_config? | SQLAlchemy → Pydantic 변환 허용 |

---

## 오늘 완료한 작업

### Phase 2: 기본 CRUD API 구현 완료!

#### 생성된 파일들

**Schemas:**
- `schemas/airline.py` - 항공사 스키마
- `schemas/carousel.py` - 캐로셀 스키마
- `schemas/flight.py` - 항공편 스키마
- `schemas/assignment.py` - 배정 스키마
- `schemas/__init__.py` - 스키마 export

**Routers:**
- `routers/airlines.py` - 항공사 API
- `routers/carousels.py` - 캐로셀 API
- `routers/flights.py` - 항공편 API
- `routers/assignments.py` - 배정 API
- `routers/__init__.py` - 라우터 export

**수정된 파일:**
- `main.py` - 라우터 등록

#### API 엔드포인트 요약

| Router | Endpoint | 기능 |
|--------|----------|------|
| airlines | `GET /api/airlines` | 항공사 목록 |
| | `GET /api/airlines/{code}` | 항공사 상세 |
| | `POST /api/airlines` | 항공사 생성 |
| | `POST /api/airlines/init` | 기본 항공사 초기화 |
| carousels | `GET /api/carousels` | 캐로셀 목록 |
| | `GET /api/carousels/{id}` | 캐로셀 상세 |
| | `POST /api/carousels` | 캐로셀 생성 |
| | `PATCH /api/carousels/{id}` | 캐로셀 수정 |
| | `POST /api/carousels/init` | C1~C24 초기화 |
| flights | `GET /api/flights` | 항공편 목록 (날짜 필터) |
| | `GET /api/flights/{id}` | 항공편 상세 |
| | `POST /api/flights` | 항공편 생성 |
| | `POST /api/flights/upload` | 벌크 업로드 |
| | `DELETE /api/flights/{id}` | 항공편 삭제 |
| assignments | `GET /api/assignments` | 배정 목록 (날짜 필터) |
| | `GET /api/assignments/{id}` | 배정 상세 |
| | `POST /api/assignments` | 배정 생성 |
| | `PUT /api/assignments/{id}` | 배정 수정 |
| | `DELETE /api/assignments/{id}` | 배정 삭제 |

---

*작성일: 2025-12-15*
