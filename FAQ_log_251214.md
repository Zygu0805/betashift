# FAQ Log - 2025-12-14

> BetaShift 프로젝트 개발 중 나온 질문과 답변 정리

---

## 1. DB 연결 테스트 방법

### Q: DB 연결 확인은 임시 엔드포인트를 추가하는 게 가장 효율적인 방법인가?

**A: 개발 단계에서는 임시 엔드포인트가 가장 효율적입니다.**

#### 다른 방법들과 비교

| 방법 | 장점 | 단점 |
|------|------|------|
| **임시 엔드포인트** | 브라우저에서 바로 확인, 설정 간단 | 나중에 삭제 필요 |
| 별도 스크립트 | 독립적 테스트 가능 | 파일 추가 생성 필요 |
| pytest | 자동화 테스트에 좋음 | 초기 설정 복잡 |
| lifespan에서 테스트 | 서버 시작 시 자동 확인 | 실패 시 서버 자체가 안 뜸 |

#### 결론
- 개발 초기 단계에서는 **임시 엔드포인트**가 가장 빠르고 직관적
- DB 연결 확인 후 삭제하거나, 나중에 `/health` 엔드포인트에 통합 가능

---

## 2. 함수 내부 import

### Q: import를 특정 함수 안에서 하는 게 생소한데, 왜 그렇게 하는 거야?

**A: 순환 참조(Circular Import) 방지를 위해서입니다.**

#### 순환 참조란?
```
main.py → database.py → (만약 database.py가 main.py를 import하면) → main.py → ...
```
무한 루프처럼 서로를 계속 import하려는 상황

#### 해결책: 함수 내부 import (Lazy Import)
```python
@app.get("/db-test")
async def db_test():
    from app.database import engine  # 함수 호출 시점에 import
    ...
```

#### 장점
- 순환 참조 방지
- 필요할 때만 로드 (메모리 효율)
- 모듈 간 의존성 느슨하게 유지

#### 언제 사용하나?
- 임시 테스트 코드
- 순환 참조 위험이 있는 경우
- 무거운 모듈을 조건부로 로드할 때

---

## 3. with...as 문법 (Context Manager)

### Q: `with engine.connect() as conn:` 이 문법은 뭐야?

**A: Context Manager - 자원을 안전하게 관리하는 Python 문법입니다.**

#### 기본 구조
```python
with 자원을_여는_함수() as 변수:
    # 자원 사용
# 블록 끝나면 자동으로 자원 정리
```

#### 동작 원리
```python
with engine.connect() as conn:
    # 작업 수행
```
위 코드는 아래와 동일합니다:
```python
conn = engine.connect()
try:
    # 작업 수행
finally:
    conn.close()  # 에러가 나도 반드시 실행
```

#### 대표적인 사용 예시
```python
# 파일 처리
with open("file.txt", "r") as f:
    content = f.read()
# 파일 자동으로 닫힘

# DB 연결
with engine.connect() as conn:
    conn.execute(...)
# 연결 자동으로 반환

# 락(Lock)
with threading.Lock():
    # 임계 영역
# 락 자동 해제
```

#### 핵심 포인트
- `as` 뒤의 변수는 `with` 블록 안에서만 유효
- 블록이 끝나면 자동으로 정리 (close, release 등)
- 예외가 발생해도 정리 코드가 실행됨

---

## 4. try-except 예외 처리

### Q: try-except 블록의 동작 방식을 설명해줘

**A: 예외(에러)가 발생할 수 있는 코드를 안전하게 감싸는 구문입니다.**

#### 기본 구조
```python
try:
    # 에러가 발생할 수 있는 코드
    위험한_작업()
except Exception as e:
    # 에러 발생 시 실행되는 코드
    print(f"에러 발생: {e}")
```

#### 실제 예시
```python
try:
    with engine.connect() as conn:
        return {"database": "connected"}
except Exception as e:
    return {"database": "failed", "error": str(e)}
```

#### 동작 흐름
1. `try` 블록 실행
2. 에러 없으면 → `except` 건너뛰고 계속 진행
3. 에러 발생하면 → `except` 블록 실행

#### Exception as e
- `Exception`: 모든 예외의 부모 클래스
- `as e`: 발생한 예외 객체를 `e` 변수에 저장
- `str(e)`: 예외 메시지를 문자열로 변환

---

## 5. str(e) 사용 이유

### Q: 왜 단순 딕셔너리는 그냥 반환하는데, 에러는 str(e)로 변환해서 반환해?

**A: JSON 직렬화(Serialization) 때문입니다.**

#### 문제 상황
```python
except Exception as e:
    return {"error": e}  # ❌ 에러! Exception 객체는 JSON으로 변환 불가
```

#### 해결책
```python
except Exception as e:
    return {"error": str(e)}  # ✅ 문자열은 JSON 변환 가능
```

#### JSON으로 변환 가능한 타입
| Python 타입 | JSON 타입 |
|------------|----------|
| dict | object |
| list | array |
| str | string |
| int, float | number |
| True/False | true/false |
| None | null |

#### Exception 객체는?
- Python 객체이므로 JSON으로 직접 변환 불가
- `str(e)`로 문자열 변환 후 반환해야 함

---

## 요약 표

| 질문 | 핵심 답변 |
|------|----------|
| DB 테스트 방법? | 개발 단계에서는 임시 엔드포인트가 가장 효율적 |
| 함수 내부 import? | 순환 참조 방지, 필요 시점에 로드 |
| with...as? | Context Manager - 자원 자동 정리 보장 |
| try-except? | 예외 발생 시 안전하게 처리 |
| str(e) 이유? | Exception 객체는 JSON 변환 불가, 문자열로 변환 필요 |

---

*작성일: 2025-12-14*
