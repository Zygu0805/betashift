# FAQ Log - 2025-12-16

## 목차
1. [Router 코드 구조](#1-router-코드-구조)
2. [라우터별 역할과 UI 연결](#2-라우터별-역할과-ui-연결)
3. [SQLAlchemy 클래스 속성 접근](#3-sqlalchemy-클래스-속성-접근)
4. [POST 초기화 엔드포인트](#4-post-초기화-엔드포인트)

---

## 1. Router 코드 구조

### Q: Router 코드의 전체 구조를 설명해줘

**A: airlines.py를 기준으로 설명합니다.**

#### Import 부분
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.database import get_db
from app.models import Airline
from app.schemas import AirlineCreate, AirlineResponse
```

| Import | 역할 |
|--------|------|
| `APIRouter` | 라우터 그룹 생성 (엔드포인트들을 묶음) |
| `Depends` | 의존성 주입 (get_db 연결에 사용) |
| `HTTPException` | HTTP 에러 응답 (404, 400 등) |
| `Session` | 타입 힌트용 (DB 세션 타입) |
| `get_db` | DB 세션을 생성/정리하는 함수 |
| `Airline` | SQLAlchemy 모델 (DB 테이블) |
| `AirlineCreate/Response` | Pydantic 스키마 (요청/응답 검증) |

#### Router 생성
```python
router = APIRouter()
```

**왜 `app.get()` 대신 `router.get()`을 쓰나?**
- main.py가 너무 길어지는 것 방지
- 기능별로 파일 분리 가능
- 코드 관리 용이

```python
# Router로 분리
# airlines.py
router = APIRouter()
@router.get("/")        # → /api/airlines

# main.py에서 등록만
app.include_router(router, prefix="/api/airlines")
```

#### 데코레이터 분석
```python
@router.get("/", response_model=list[AirlineResponse])
#       ↑ HTTP 메서드   ↑ 응답 형식 지정

@router.post("/", response_model=AirlineResponse, status_code=201)
#                                                 ↑ 성공 시 201 반환
```

#### DB 쿼리 패턴
```python
# 전체 조회
db.query(Airline).all()
# SQL: SELECT * FROM airlines

# 조건 조회
db.query(Airline).filter(Airline.airline_code == airline_code).first()
# SQL: SELECT * FROM airlines WHERE airline_code = 'KE' LIMIT 1
```

#### DB 저장 과정
```python
db_airline = Airline(**airline.model_dump())  # 1. 모델 객체 생성
db.add(db_airline)                            # 2. 세션에 추가
db.commit()                                   # 3. DB에 실제 저장
db.refresh(db_airline)                        # 4. DB에서 다시 읽기
return db_airline
```

| 단계 | 설명 |
|------|------|
| `add()` | "이거 저장할 거야" (아직 안 함) |
| `commit()` | "진짜 저장해!" (DB에 반영) |
| `refresh()` | DB에서 최신 값 다시 읽기 |

---

## 2. 라우터별 역할과 UI 연결

### Q: DB CRUD를 먼저 만드는 이유는? 각 라우터가 어떤 UI와 연결돼?

**A: FK 관계 때문에 순서대로 만들어야 하고, 라우터마다 연결되는 UI가 다릅니다.**

#### 시스템 구조
```
┌─────────────────────────────────────────────────────────┐
│                    BetaShift 시스템                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  [Admin 영역]                  [사용자 영역]              │
│  ┌─────────────┐              ┌─────────────────┐       │
│  │ airlines    │              │ assignments     │       │
│  │ - 항공사 관리│              │ - 배정 조회     │       │
│  │ - 색상 설정 │              │ - 드래그앤드롭  │       │
│  ├─────────────┤              │ - 충돌 검증     │       │
│  │ carousels   │              │ - AI 자동 배정  │       │
│  │ - 캐로셀 관리│              └─────────────────┘       │
│  │ - C1~C24    │                      ↑                 │
│  ├─────────────┤                      │                 │
│  │ flights     │──────────────────────┘                 │
│  │ - 항공편 등록│   (항공편 데이터 기반으로 배정)         │
│  └─────────────┘                                        │
└─────────────────────────────────────────────────────────┘
```

#### 각 라우터의 실제 용도

| 라우터 | 사용 빈도 | 주 사용자 | UI 연결 |
|--------|----------|----------|---------|
| **airlines** | 초기 1회 | 관리자 | Admin 페이지 (또는 없음) |
| **carousels** | 초기 1회 | 관리자 | Admin 페이지 (또는 없음) |
| **flights** | 매일 | 관리자/시스템 | 데이터 업로드 페이지 |
| **assignments** | 실시간 | 운영자 | **메인 바차트 UI** |

#### 생성 순서가 중요한 이유
```
1. airlines, carousels (기초 데이터)
   ↓ 이게 있어야
2. flights (항공편 등록 가능) - Airline FK 참조
   ↓ 이게 있어야
3. assignments (배정 가능) - Flight, Carousel FK 참조
```

#### 메인 UI에서 사용할 API
```python
# 1. 날짜별 배정 현황 조회 (바차트 렌더링)
GET /api/assignments?date=2025-12-16

# 2. 드래그앤드롭으로 배정 변경
PUT /api/assignments/{id}

# 3. 색상 정보 가져오기 (항공사별 바 색상)
GET /api/airlines

# 4. AI 자동 배정 (Phase 4에서 추가 예정)
POST /api/assignments/ai-assign
```

---

## 3. SQLAlchemy 클래스 속성 접근

### Q: 인스턴스 없이 `Airline.airline_code`로 접근 가능한 이유는?

**A: SQLAlchemy Column이 디스크립터 패턴으로 구현되어 있기 때문입니다.**

#### 일반 Python vs SQLAlchemy
```python
# 일반 Python 클래스
class Airline:
    def __init__(self):
        self.airline_code = "KE"

Airline.airline_code  # ❌ AttributeError

# SQLAlchemy 모델
class Airline(Base):
    airline_code = Column(String(10), primary_key=True)

Airline.airline_code  # ✅ 작동함!
```

#### Column의 이중 역할

| 상황 | 반환 값 | 용도 |
|------|---------|------|
| 클래스에서 접근 | `InstrumentedAttribute` | 쿼리 조건용 |
| 인스턴스에서 접근 | 실제 값 (`"KE"`) | 데이터 접근 |

```python
# 클래스에서 접근 (쿼리용)
Airline.airline_code == "KE"
# → SQL: WHERE airline_code = 'KE' 조건 객체 생성

# 인스턴스에서 접근 (값)
airline = db.query(Airline).first()
airline.airline_code
# → "KE" (실제 문자열)
```

#### 내부 동작 (디스크립터 패턴)
```python
# 단순화한 개념
class Column:
    def __get__(self, obj, owner):
        if obj is None:  # 클래스에서 접근
            return QueryableAttribute(...)  # 쿼리용 객체
        else:            # 인스턴스에서 접근
            return obj._data[self.name]     # 실제 값
```

---

## 4. POST 초기화 엔드포인트

### Q: `/init` 엔드포인트의 설계 의도와 동작 방식은?

**A: 개발 시 초기 데이터를 빠르게 세팅하기 위한 API입니다.**

#### 설계 의도
```
개발 시작 → DB 비어있음 → 항공편 등록하려면 Airline FK 필요
→ 8개 하나씩 POST? 귀찮음 → 한 번에 초기화하는 API!
```

#### 중복 방지 로직
```python
created = []
for airline_data in default_airlines:
    existing = db.query(Airline).filter(
        Airline.airline_code == airline_data["airline_code"]
    ).first()

    if not existing:  # 없을 때만 생성
        db_airline = Airline(**airline_data)
        db.add(db_airline)
        created.append(db_airline)
```

**멱등성에 가깝게 동작:**
```
첫 번째 호출: 8개 생성 ✅
두 번째 호출: 0개 생성 (이미 있음) ✅
→ 여러 번 호출해도 안전!
```

#### commit을 루프 밖에서 하는 이유
```python
# 나쁜 예 (느림)
for airline_data in default_airlines:
    db.add(...)
    db.commit()  # 8번 DB 왕복!

# 좋은 예 (빠름)
for airline_data in default_airlines:
    db.add(...)
db.commit()  # 1번 DB 왕복!
```

#### refresh가 필요한 이유
```python
db_airline = Airline(airline_code="KE", ...)
# 이 시점: 메모리에만 존재

db.commit()
# 이 시점: DB에 저장됨, 하지만 객체는 "stale" 상태

db.refresh(db_airline)
# 이 시점: DB에서 최신 값 다시 읽어옴 (created_at 등 자동생성 값 반영)
```

#### 반환 값
| 호출 | 반환 |
|------|------|
| 첫 번째 | `[KE, OZ, 7C, TW, LJ, ZE, BX, RS]` (8개) |
| 두 번째 | `[]` (이미 다 있음) |

#### 프로덕션에서는?
```python
# 옵션 1: 삭제
# init 엔드포인트 자체를 제거

# 옵션 2: 권한 제한
@router.post("/init")
def init_airlines(
    db: Session = Depends(get_db),
    admin: User = Depends(get_admin_user)  # 관리자만!
):
```

---

## 요약 표

| 질문 | 핵심 답변 |
|------|----------|
| Router를 왜 분리? | main.py 비대화 방지, 기능별 파일 분리 |
| 라우터별 역할? | airlines/carousels=Admin, assignments=메인 UI |
| CRUD 순서 중요? | FK 관계 때문에 airlines→flights→assignments 순서 |
| 클래스에서 Column 접근? | SQLAlchemy 디스크립터 패턴 (쿼리용 객체 반환) |
| /init 엔드포인트? | 개발용 초기 데이터 세팅, 중복 방지 로직 포함 |
| commit 루프 밖? | DB 왕복 최소화 (성능) |
| refresh 필요? | 자동생성 값(created_at 등) 반영 |

---

## 오늘 진행 상황

- Router 코드 분석 완료 (airlines.py)
- 시스템 구조 및 라우터 역할 이해
- Phase 3 (배정 로직 구현) 진행 예정

---

*작성일: 2025-12-16*
