# FAQ Log - 2025-12-11

> BetaShift 프로젝트 개발 중 나온 질문과 답변 정리

---

## 1. Conda 환경 관련

### Q: 이미 터미널이 Conda 환경 안에 있으면 굳이 가상환경을 따로 만들 필요는 없는 거야?

**A: 프로젝트별로 가상환경을 따로 만드는 것을 강력히 권장합니다.**

#### 이유
- **패키지 충돌 방지**: 프로젝트A는 `requests==2.25`, 프로젝트B는 `requests==2.31`이 필요할 수 있음
- **base 환경 보호**: base가 꼬이면 Anaconda 전체 재설치 필요
- **배포 용이**: `requirements.txt`로 해당 프로젝트의 정확한 의존성만 관리 가능

#### 권장 구조
```
conda (base) ─── 건드리지 않음 (깨끗하게 유지)
    │
    ├── betashift (새 환경) ─── BetaShift 전용
    │
    └── other-project (다른 환경) ─── 다른 프로젝트용
```

#### 실무 원칙
> **"하나의 프로젝트 = 하나의 가상환경"**

---

## 2. PostgreSQL 관련

### Q: pgAdmin으로 PostgreSQL을 구동시켜놔서 서버가 돌아가고 있는 건가? 앞으로 항상 pgAdmin을 켜놓고 개발해야 하나?

**A: 아니요! pgAdmin은 안 켜도 됩니다.**

#### PostgreSQL 구조
```
┌─────────────────────────────────────────────────────┐
│  PostgreSQL 서버 (백그라운드 서비스)                   │
│  - Mac 부팅 시 자동 실행                              │
│  - 항상 켜져 있음                                     │
│  - 포트 5432에서 대기 중                              │
└─────────────────────────────────────────────────────┘
        ▲               ▲               ▲
        │               │               │
   ┌────┴────┐    ┌────┴────┐    ┌─────┴─────┐
   │ pgAdmin │    │  psql   │    │ FastAPI   │
   │ (GUI)   │    │(터미널) │    │ (우리 앱) │
   └─────────┘    └─────────┘    └───────────┘
      클라이언트들 (접속 도구)
```

#### 핵심
- PostgreSQL 서버 → Mac 부팅할 때 자동 시작됨 (백그라운드)
- pgAdmin → 서버에 "접속"하는 GUI 클라이언트일 뿐
- pgAdmin에서 비밀번호 입력 = 서버 시작이 아니라 이미 실행 중인 서버에 "접속"

#### 개발 흐름
1. Mac 켠다 → PostgreSQL 서버 자동 실행됨
2. 터미널에서 `conda activate betashift`
3. FastAPI 서버 실행
4. 끝! (pgAdmin 필요 없음)

---

## 3. 패키지 관련

### Q: uvicorn, psycopg2-binary, python-dotenv의 용도와 설치 이유는?

---

### 3-1. uvicorn - ASGI 서버

#### 왜 필요한가?
FastAPI는 **웹 프레임워크**일 뿐, 혼자서는 HTTP 요청을 받을 수 없습니다.

```
클라이언트 (브라우저, React 앱)
        │ HTTP 요청
        ▼
uvicorn (서버) ─── HTTP 요청을 받아서 FastAPI에게 전달
        │
        ▼
FastAPI (프레임워크) ─── 요청 처리, 응답 생성
```

#### ASGI란?
| 용어 | 설명 |
|------|------|
| **WSGI** | 예전 방식, 동기 처리만 가능 (Flask, Django 기본) |
| **ASGI** | 최신 방식, 비동기 처리 가능 (FastAPI, WebSocket 지원) |

---

### 3-2. psycopg2-binary - PostgreSQL 드라이버

#### 왜 필요한가?
Python과 PostgreSQL은 서로 다른 시스템. 통역사(드라이버)가 필요합니다.

```
우리 코드 → SQLAlchemy (ORM) → psycopg2 (드라이버) → PostgreSQL
```

#### ORM만으로 충분하지 않나?
- SQLAlchemy는 **Python 객체 → SQL 문자열 변환**만 담당
- SQL을 실제로 DB에 **보내는 것**은 psycopg2가 담당
- 각 DB마다 전용 프로토콜이 다르기 때문에 드라이버가 필요

| 데이터베이스 | 드라이버 |
|-------------|---------|
| PostgreSQL | psycopg2 |
| MySQL | pymysql |
| SQLite | sqlite3 (내장) |

---

### 3-3. python-dotenv - 환경변수 관리

#### 왜 필요한가?
코드에 민감한 정보를 직접 쓰면 위험합니다.

```python
# ❌ 절대 이렇게 하면 안 됨
DATABASE_URL = "postgresql://postgres:mypassword123@localhost/betashift"
```

#### 해결책: .env 파일
```
# .env 파일 (Git에 올리지 않음)
DATABASE_URL=postgresql://postgres:mypassword123@localhost/betashift
```

```python
# main.py
from dotenv import load_dotenv
import os

load_dotenv()
database_url = os.getenv("DATABASE_URL")  # 안전하게 가져오기
```

#### 장점
| 장점 | 설명 |
|------|------|
| **보안** | 민감 정보가 코드에 없음 |
| **유연성** | 환경별로 다른 설정 가능 (개발/운영) |
| **협업** | `.env.example`만 공유, 실제 값은 각자 설정 |

---

## 4. 아키텍처 심화

### Q: FastAPI가 웹 프레임워크일 뿐이라는 건 어떤 의미? uvicorn은 어떤 레벨에서 동작하길래 HTTP 요청을 받을 수 있는 거야?

**A: 전체 흐름을 하드웨어부터 보면 이해가 됩니다.**

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. 하드웨어 계층                                                  │
│    - 네트워크 카드(NIC)가 전기 신호로 데이터 수신                    │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. OS 커널 (macOS/Linux)                                        │
│    - TCP/IP 스택이 패킷을 해석                                    │
│    - 포트 5432, 8000 등으로 데이터 라우팅                          │
│    - Socket API 제공                                             │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. uvicorn (Python 프로세스)                                     │
│    - OS의 Socket API를 사용해서 포트 8000을 "점유"                 │
│    - TCP 연결 수락 (accept)                                      │
│    - 받은 바이트를 HTTP 프로토콜로 파싱                            │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. ASGI 인터페이스                                               │
│    - uvicorn이 파싱한 요청을 표준화된 형식으로 변환                  │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. FastAPI                                                      │
│    - ASGI 형식의 요청을 받아서 라우팅, 검증, 응답 생성              │
└─────────────────────────────────────────────────────────────────┘
```

### Q: uvicorn은 FastAPI 전용인가?

**A: 아니요!** uvicorn은 **ASGI 표준**을 따르는 모든 프레임워크와 호환됩니다.

| 프레임워크 | uvicorn 사용 가능 |
|-----------|------------------|
| FastAPI | ✅ |
| Starlette | ✅ |
| Django (ASGI 모드) | ✅ |
| Quart | ✅ |

---

### Q: ORM만으로 DB 통신이 가능하다고 생각했는데, psycopg2는 왜 필요해?

**A: ORM과 드라이버는 역할이 다릅니다.**

```
┌────────────────────────────────────────────────────┐
│ SQLAlchemy (ORM)                                   │
│ - Python 객체 → SQL 문자열 변환                     │
│ - "INSERT INTO users (name) VALUES ('Kim')"        │
│ - 하지만 SQL 문자열을 DB로 "보내는 방법"은 모름       │
└────────────────────────────────────────────────────┘
                         ▼
┌────────────────────────────────────────────────────┐
│ psycopg2 (드라이버)                                 │
│ - PostgreSQL 서버와 TCP 연결 수립                   │
│ - PostgreSQL 전용 프로토콜로 SQL 전송               │
│ - 인증, 암호화, 결과 수신 등 처리                    │
└────────────────────────────────────────────────────┘
```

#### 비유
- **SQLAlchemy** = 비서 (메일 내용 작성)
- **psycopg2** = 메일 프로그램 (실제 전송)

---

## 요약 표

| 질문 | 핵심 답변 |
|------|----------|
| 가상환경 꼭 필요해? | 프로젝트별로 분리 권장 (충돌 방지, 배포 용이) |
| pgAdmin 항상 켜야 해? | 아니요, PostgreSQL 서버는 자동 실행됨 |
| uvicorn 역할? | FastAPI를 실행시켜주는 ASGI 서버 |
| psycopg2 역할? | Python ↔ PostgreSQL 통신 드라이버 |
| python-dotenv 역할? | 민감 정보(.env)를 안전하게 관리 |

---

## 5. database.py 관련

### Q: os.getenv()는 어떻게 동작해?

**A: 환경변수를 읽어오는 함수입니다.**

```python
DATABASE_URL = os.getenv(
    "DATABASE_URL",  # 첫 번째 인자: 환경변수 이름
    "postgresql://postgres:postgres@localhost:5432/betashift"  # 두 번째 인자: 기본값
)
```

#### 동작 순서
1. `DATABASE_URL`이라는 환경변수가 있는지 확인
2. 있으면 → 그 값 사용
3. 없으면 → 두 번째 인자(기본값) 사용

#### .env 파일과의 관계
```python
load_dotenv()  # .env 파일의 내용을 환경변수로 로드
os.getenv("DATABASE_URL")  # 이제 .env에 있는 값을 읽을 수 있음
```

---

### Q: SQLAlchemy에서 import하는 것들(create_engine, declarative_base, sessionmaker, Session)은 뭐야?

**A: 각각 역할이 다릅니다.**

| import | 역할 |
|--------|------|
| `create_engine` | DB 연결 엔진 생성 (Connection Pool 포함) |
| `declarative_base` | 모델 클래스의 부모 클래스 생성 |
| `sessionmaker` | Session 클래스를 만드는 팩토리 |
| `Session` | 타입 힌트용 (실제 사용은 sessionmaker가 만든 클래스) |

#### 관계도
```
create_engine → Engine (연결 풀 관리)
                  ↓
sessionmaker(bind=engine) → SessionLocal (세션 팩토리)
                               ↓
SessionLocal() → Session 인스턴스 (실제 DB 작업)
```

---

### Q: DB 연결을 여러 개 만들어놓는다는 게 무슨 의미야? Connection Pool이 뭐야?

**A: Connection Pool은 미리 만들어둔 DB 연결들의 "대기실"입니다.**

#### 왜 필요한가?
DB 연결을 새로 만드는 건 비용이 큽니다 (TCP 연결 + 인증 + 설정).

```
Pool 없이:
요청1 → 연결 생성(0.1초) → 쿼리 실행 → 연결 종료
요청2 → 연결 생성(0.1초) → 쿼리 실행 → 연결 종료  ← 매번 0.1초 낭비!

Pool 사용:
서버 시작 → 연결 5개 미리 생성 (Pool)
요청1 → Pool에서 연결 빌림 → 쿼리 실행 → Pool에 반납
요청2 → Pool에서 연결 빌림 → 쿼리 실행 → Pool에 반납  ← 즉시 사용!
```

#### 비유
- **Pool 없이** = 매번 렌터카 계약서 작성
- **Pool 사용** = 회사 차량 빌려서 쓰고 반납

---

### Q: psycopg2를 database.py에서 직접 import 안 하는데, 어떻게 사용되는 거야?

**A: SQLAlchemy가 내부적으로 자동 로드합니다.**

```python
# DATABASE_URL의 postgresql:// 부분을 보고 SQLAlchemy가 판단
DATABASE_URL = "postgresql://..."  # ← 이걸 보고 psycopg2를 찾아서 사용

engine = create_engine(DATABASE_URL)  # 내부에서 psycopg2 자동 import
```

#### 명시적으로 지정하려면
```python
# 드라이버를 URL에 명시
DATABASE_URL = "postgresql+psycopg2://..."
```

---

### Q: psycopg2-binary와 psycopg2의 차이는?

**A: binary는 미리 컴파일된 버전입니다.**

| 패키지 | 특징 |
|--------|------|
| `psycopg2-binary` | 미리 빌드됨, 설치 쉬움, 개발용 권장 |
| `psycopg2` | 직접 컴파일 필요, C 컴파일러 필요, 프로덕션 권장 |

#### 왜 프로덕션에서는 psycopg2?
- binary 버전은 시스템 라이브러리와 충돌 가능성 있음
- 프로덕션에서는 안정성이 더 중요

#### 개발 단계에서는?
- `psycopg2-binary`로 충분! 나중에 배포할 때 바꾸면 됨

---

## 6. Generator와 Session

### Q: Generator 문법과 get_db()에서 사용된 이유는?

**A: Generator는 값을 "양보(yield)"하고 나중에 다시 돌아올 수 있는 함수입니다.**

#### 기본 Generator
```python
def count_up():
    yield 1
    yield 2
    yield 3

for num in count_up():
    print(num)  # 1, 2, 3
```

#### get_db()에서의 사용
```python
def get_db() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db  # ← 여기서 일시정지, db를 호출자에게 전달
    finally:
        db.close()  # ← yield 이후 코드는 나중에 실행됨
```

#### 왜 Generator를 쓰나?
**자원 정리를 보장하기 위해서!**

```
1. get_db() 호출
2. db = SessionLocal() 실행
3. yield db → db 객체를 FastAPI에게 전달, 함수 일시정지
4. FastAPI가 db로 작업 수행
5. 요청 처리 완료 (또는 에러 발생)
6. finally 블록의 db.close() 실행 ← 무조건 실행됨!
```

#### Generator[Session, None, None] 타입 힌트
```python
Generator[YieldType, SendType, ReturnType]
         [Session,   None,     None      ]
```
- `Session`: yield로 내보내는 타입
- `None`: 외부에서 send()로 보내는 값 (사용 안 함)
- `None`: return 값 (사용 안 함)

---

### Q: Connection Pool의 연결과 Session은 다른 건가?

**A: 다릅니다! 계층이 다릅니다.**

```
┌─────────────────────────────────────────┐
│ Session (세션)                           │
│ - 트랜잭션 관리                          │
│ - ORM 객체 추적                          │
│ - 하나의 "작업 단위"                     │
└─────────────────────────────────────────┘
                    ↓ 사용
┌─────────────────────────────────────────┐
│ Connection (연결)                        │
│ - 실제 DB와의 TCP 연결                   │
│ - Pool에서 빌려옴                        │
└─────────────────────────────────────────┘
                    ↓ 통신
┌─────────────────────────────────────────┐
│ PostgreSQL 서버                          │
└─────────────────────────────────────────┘
```

#### 비유
- **Connection** = 전화선 (물리적 연결)
- **Session** = 통화 내용 (논리적 작업 단위)

#### 관계
- Session이 시작되면 Pool에서 Connection을 빌림
- Session이 끝나면 Connection을 Pool에 반납
- 하나의 Session = 하나의 Connection 사용 (동시에 여러 개 X)

---

### Q: get_db() 호출 시 Generator 객체가 생성되고, FastAPI의 Depends가 처리하는 거지?

**A: 정확합니다!**

#### 흐름
```python
@app.get("/items")
def get_items(db: Session = Depends(get_db)):
    return db.query(Item).all()
```

1. `/items` 요청 들어옴
2. FastAPI가 `Depends(get_db)` 확인
3. `get_db()` 호출 → Generator 객체 생성
4. `next(generator)` 호출 → `yield db`까지 실행, db 반환
5. `get_items(db=db)` 실행
6. 응답 반환
7. Generator 정리 → `finally: db.close()` 실행

#### Depends의 역할
- Generator 함수를 자동으로 처리
- yield 전까지 실행 → 값 주입
- 요청 끝나면 → finally 실행

---

## 요약 표 (추가)

| 질문 | 핵심 답변 |
|------|----------|
| os.getenv? | 환경변수 읽기, 없으면 기본값 사용 |
| Connection Pool? | 미리 만든 DB 연결 대기실, 성능 향상 |
| psycopg2 import 안 하는데? | SQLAlchemy가 URL 보고 자동 로드 |
| psycopg2 vs binary? | binary는 개발용, 일반은 프로덕션용 |
| Generator 왜 사용? | 자원 정리(close) 보장을 위해 |
| Session vs Connection? | Session은 논리적 작업단위, Connection은 물리적 연결 |

---

*작성일: 2025-12-11*
*업데이트: 2025-12-14 (database.py, Generator, Session 관련 추가)*
